* System
** What is it?
System owes to [[https://github.com/stuartsierra/component][component]] both in spirit and in name. Component gave you the ability to implement the reload pattern as promoted by Stuart Sierra, System gives you a set of readymade components. This set is open to contributions from the community and so is expected to expand. Currently includes: 

- Jetty (HTTP server)
- Http-kit (Async HTTP server)
- Datomic (Immutable database)
- Monger (MongoDB client)
- Sente (Websockets/Ajax communications library)
- nREPL (Clojure network REPL )
- Langohr (RabbitMQ client)

** Motivation
Having a good experience at the REPL is all what a Lisp is about. Reloaded components find themselves in almost every project, since most applications require external dependencies (a web server, a database, etc.). My first attempt to tackle the problem of avoiding boilerplate code was to use a Leiningen template. The problem is that Leiningen templates are hard to maintain, and difficult to retrofit on exisiting projects. As time goes by, dependencies get new versions, and I found myself painstakingly updating a bad solution. Then it dawned on me that a library would better fit the bill. And so *System* came to light. I now use it in every project with tremendous productivity boost.
** Is it good?
[[https://news.ycombinator.com/item?id%3D3067434][Yes]].
** Installation
Add the following to the Leiningen dependencies in project.clj. 
#+BEGIN_SRC 
[org.danielsz/system "0.1.0-SNAPSHOT"]
#+END_SRC


** Usage

First, assemble your system(s) in a namespace of your choosing. Here we define two systems, development and production. 
#+BEGIN_SRC clojure
(ns my-app.systems
  (:require 
   [com.stuartsierra.component :as component]
   (system.components 
    [jetty :refer [new-web-server]]
    [repl-server :refer [new-repl-server]]
    [datomic :refer [new-datomic-db]]
    [mongo :refer [new-mongo-db]])
   [my-app.webapp :refer [handler]]
   [environ.core :refer [env]]))

(defn dev-system []
  (component/system-map
   :datomic-db (new-datomic-db (env :db-url))
   :mongo-db (new-mongo-db)
   :web (new-web-server (env :http-port) handler)))

(defn prod-system []
  "Assembles and returns components for a production application"
  []
    (component/system-map
     :datomic-db (new-datomic-db (env :db-url))
     :mongo-db (new-mongo-db (env :mongo-url))
     :web (new-web-server (env :http-port) handler)
     :repl-server (new-repl-server (env :repl-port))))

#+END_SRC

Note: Component allows you to define dependency relationships within systems. Be sure to consult Componentâ€™s API to see the range of options.

Then, in user.clj:
#+BEGIN_SRC clojure
(ns user
  (:require [reloaded.repl :refer [system init start stop go reset]]
            [my-app.systems :refer [dev-system]]))

(reloaded.repl/set-init! dev-system)
#+END_SRC
You can then manipulate the system in the REPL: ~(go)~, ~(reset)~ or ~(stop)~. The system map is accessible at any time, it resides in a var named, as you can guess, ~system~. 

In production, in core.clj:

#+BEGIN_SRC clojure
(ns my-app.core
  (:gen-class)
  (:require [my-app.systems :refer [prod-system]]))

(defn -main 
  []
  "Start the application"
  (alter-var-root #'prod-system component/start)
#+END_SRC 

Or, if you want to keep a handler on your system in production:

#+BEGIN_SRC clojure
(ns my-app.core
  (:gen-class)
  (:require [reloaded.repl :refer [system init start stop go reset]]
            [my-app.systems :refer [prod-system]]))

(defn -main 
  []
  "Start the application"
  (reloaded.repl/set-init! prod-system)
  (go))
#+END_SRC


** Contributing
Please fork and issue a pull request to add more components. Please don't forget to include tests. You can refer to the existing ones to get started.
